<!--
 * @Author: your name
 * @Date: 2020-12-10 22:36:50
 * @LastEditTime: 2020-12-11 21:58:02
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \webRTC\public\index.html
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频共享</title>
</head>
<body>
    <!-- 创建视频标签 -->
    <video id="vid" autoplay muted></video>
    <button class="start">开始</button>
    <button class="stop">停止</button>
    <script>
        const localVideo = document.querySelector("#vid");
        const start = document.querySelector(".start");
        const stop = document.querySelector(".stop");
        let stereo = false; // sdp

        async function createConnection(){
            const response1 = await fetch('/connections/inite',{method: 'POST'});
            const { id, localDescription} = await response1.json();
            const localPeerConnection = new RTCPeerConnection({
                sdpSemantics: 'unified-plan'
            });
            localPeerConnection.close = function () {
                fetch(`/connections/inite/${id}`, {method: 'delete'}).catch((err)=>console.log(err));
                return RTCPeerConnection.prototype.close.apply(this, arguments);
            }

            try {
                await localPeerConnection.setRemoteDescription(localDescription);
                await beforeAnswer(localPeerConnection);
                const originalAnswer = await localPeerConnection.createAnswer();
                const updatedAnswer = new RTCSessionDescription({
                    type: 'answer',
                    sdp: stereo ? enableStereoOpus(originalAnswer.sdp) : originalAnswer.sdp
                });

                await localPeerConnection.setLocalDescription(updatedAnswer);

                await fetch(`/connections/inite/${id}/remote-description`, {
                    method: 'POST',
                    body: JSON.stringify(localPeerConnection.localDescription),
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                return localPeerConnection;
            } catch(e){
                localPeerConnection.close();
                console.log(e);
            }
        }

        async function beforeAnswer(peerConnection) {
            const localStream = await window.navigator.mediaDevices.getUserMedia({
                audio: false,
                video: true
            });
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream))
            localVideo.srcObject = localStream;
            let { close } = peerConnection;
            peerConnection.close = function() {
                localVideo.srcObject = null;
                localStream.getTracks().forEach(track => track.stop());
                return close.apply(this, arguments);
            };
        }

        function enableStereoOpus(sdp) {
            return sdp.replace(/a=fmtp:111/, 'a=fmtp:111 stereo=1\r\na=fmtp:111');
        }
        let peerConnection = null;
        start.addEventListener('click', async ()=>{
            peerConnection = await createConnection();
        });
        stop.addEventListener('click', ()=>{
            peerConnection.close();
        })


    </script>
</body>
</html>